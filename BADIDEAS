Bad Ideas
===========

Design ideas which seem appealing or reasonable but are dead ends for some reason.

Counterexample for implementing history tracks with linear undo:
----------------------------------------------------------------

Suppose the following history graph, where G1 is initially a sub-group of
doc1.

doc1---G1-----.------.------.--------.-------------. current state
       |
       | move G1 to doc2
       | and also edit
       | properties of G1
       |
      \|/ 
doc2------------add G2 to doc2----add G3 to doc2--------------. current state

Now suppose we start undoing on doc1's history track.
When we reach the point where we undo the commit that moved G1 from
doc1 to doc2:
 -  suppose we just apply the part of the commit that set's
    G1's parent to doc1. This will cause a partial edit to doc2 - breaking
	the property that undo/redo doesn't cause docuement edits, but just
	moves tags.
 - the only other way would be to revert doc2's tag to the state before
   G1 was added to doc2.. but this would cause doc2 to lose G2 and G3!

The same problem would happen even if moving G1 from doc1 to doc2 was 
not atomic. The conclusion is that when there is any kind of interaction
between two documents, the linear undo track model breaks.

Considering that we need to implement a selective undo-based history track
for group editing anyway *, we should probably use that in the gerenal case.

* in the literature it's called "local undo" - if you and a collaborator
make interleaved edits to a document, when you invoke undo, only your
local changes (the changes you made on your computer) should be undone, by
default. Without this feature, undo in a group editor is next to useless
because when you invoke an undo, you never know if it will undo your last change,
or your system will recieve a commit from your collaborator and immediately 
(unintentinally) undo it.




Q: Can we avoid storing 'tip' by just looking for the newest non-hidden
commit on a branch? looks like yes... But actually no, because we can e.g.
set the tip to be the end of an anonymous branch without comitting to it.



Meta-History (History of history operations, i.e. undo/redo)
------------------------------------------------------------

Question: Should changes to the mutable part of the store be attached to a commit?
i.e. the commit metadata? Do we want "undo" or "redo" or "change branch" to show up 
in the history log?

A: It seems sensible,.. but if you consider the history log with a branch graph view,
it makes it clear that these are meta-operations. Do we want/need "meta-history"?
It's probably unnecessary and a lot of complexity to implement.

Emacs' undo system provides this but it's kind of a pain; it's only advantage
in emacs is to make up for not properly modeling branching undo.
