Design Ideas
==============

Attributed String Merging
-------------------------
If we used one object per character, this would work out of the box.

Example:

			    /--> "_eto_ile" (underline)
      "etoile"
	           \--> "e*toile*" (bold)
			   
merging the two branches shouldn't conflict, because a character can be both
bold and underlined.  but if we modeled it as:

ORIGINAL: textRuns : ( { uuid : u1, string : 'etoile'} )
  
V1:       textRuns : ( { uuid : u2, string : 'eto', attrs : underline }, { uuid : u3, string : 'ile' } )

V2:       textRuns : ( { uuid : u4, string : 'e' }, { uuid : u5, string : 'toile', attrs : bold } )
  
The merge would have conflicts, but we don't want it to.

However... 

			    /--> "_eto_ile" (heading level 1)
      "etoile"
	           \--> "e*toile*" (heading level 2)

Merging these should conflict, because a character can only have one heading level.



Will splitting/recombining cause problems with object identity?
-> It means we can't give any semantics to the UUID of a run of text.
This is probably OK.
        



Object graph diff
-----------------

Needs to be rewritten as the current design isn't very intelligent.

diffing two containers:

c1, c2 where uuid(c1) == uuid(c2)

We want a deafult policy which has sensible results in 99% of cases.
How should our default policy handle one-to-many relationships vs many-to-many?

Move/Delete:

- for a one-to-many relationship (COContainer), when merging two diffs
where one deletes an object and the other diff moves it, the delete should win.

- for a many-to-many relationship (COCollection), when merging two diffs
where one deletes an object and the other diff moves it, the move should win.

Insert/Insert:

- one-to-many: conflict if the inserts are in different places.
- many-to-many: both sides succeed if the inserts are in different places.

Move/Move

- one-to-many: conflict if the move destinations are in different places.
- many-to-many: both sides succeed if the move destinations are in different places.

any other cases?

We need to perserve relationship consistency when merging,
so we need to sort out relationship modifications from other edits. And pair up
both sides of the edits, since diffs will have changes to both sides.


Branching Models
----------------
Possibilities:
 - git style: branches happen at the entire-repository level. so creating a
   branch conceptually takes a snapshot of the entire repository. while this 
   is simple, it wouldn't work so well for CoreObject because
	typically you just want to branch one document or one project, not every
	object on your system 

 - The approach I was trying was having per-object branches managed at the
	store level, but it's looking to be really complicated.
	
 - subversion style: branching is making a copy. one problem with the
   subversion implementation of this idea is branches live in the
   same namespace as the filesystem, which you could argue is a bad idea,
   since branching is sort of a meta-level operation.

Here is a good blog post explaining the limitations of DAG-based vcs's
(git/mercurial/bazaar/etc.), compared with subversion's more flexible
branching model:
http://softwareswirl.blogspot.com/2009/08/git-mercurial-and-bazaarsimplicity.html

See also:
http://www.bcs-cmsg.org.uk/conference/2003/papers/wingerd.pdf
"Container-Based SCM and Inter-File Branching" describing Perforce's branching
model (sounds the same as subversion - making copies of directories - but
perforce had accurate branch/merge metadata several years before Subversion) 

Selective Undo
-------------

"A Selective Undo Mechanism for Graphical User Interfaces Based On Command Objects"
by Thomas Berlage makes a good case for 'direct selective undo' (what I implemented)
rather than "script-based" selective undo.

We will use the 'opposite' property description metamodel property to indicate
that relationship integrity maintainence should be performed.