TODO
====

First alpha release blockers
----------------------------

- Shorten -[COObject description] output

- Improve -[COObject detailedDescription] code and make output more readable

- Check and update all Core API documentation (underway)

- Check code quality for all Core classes (underway)

- Support dictionaries in -collectionForProperty:removalIndex: and -collectionForProperty:insertionIndex: (write some tests too)

- Remove automatic keyed archiving in COSerialization and require explicit serialization accessors (containing code such as [NSKeyedArchiver archivedDataWithRootObject: value])


Future Work
-----------

- Store

  - exportRevisions: and importRevisions: that take a set of CORevisionID an returns a delta-compressed NSData
    suitable for network transport.
	
  - GC: only collect divergent revisions older than X days
  
  -  Switch from FMDB to an SQL abstraction backend

- COEditingContext

  - Expose COSQLiteStore's attachments feature

  - expose COSQLiteStore's finalize deletion method

  - expose store's searching functionality (integrate COSearchResult and COQuery)

  - Switch to NSUUID everywhere?


- COPersistentRoot

  - test [[persistentRoot currentBranch] currentRevision] on a newly created
    persistent root
	
  - Making additional changes to an uncomitted cheap copy persistent root is broken (we
    don't look at the COObjectGraphContext)
	
  - Refactor handling of store notifications and test it more thoroughly. Should
    post a persistent root change notification to the application if we load
	changes that another process made in the store.

	
- COBranch

  - Extend COBranch API to support branches and merging revisions accross tracks

  - Extract selective undo code from undo system
  
  - Implement selective undo in -[COBranch undoNode:]


- Metamodel

  - Add checks that derived properties are not persistent

  - Add check that parent property (isContainer = YES) is derived

  - Add check that one side of an opposite is derived

  - Review other constraints

  - Add a check that the derived side of a multivalued opposite is unordered

  - Add an "indexed" flag to ETPropertyDescription to tell the store whether to include values of that property in search indexes

  - Move to CoreObject

  - Scan over every loaded ObjC class is ugly

  - Improve metamodel checker to ensure matching Objective-C property types (e.g. a ETCollection must be declared as multivalued, a NSArray as ordered)


- COObject

  - Better error message if you try to use a composite relationship across persistent roots, 
    currently you get a COPath does not respond to UUIDValue exception.

  - We should have dedicated array/set multivalue mutation methods rather than using:
    -[COObject (void)insertObject: (id)object atIndex: (NSUInteger)index hint: (id)hint forProperty: (NSString *)key]
    for both, IMO (Eric)

  - Use NSSortedSet for sorted composite relationships

  - Use weak references to other COObject instances to prevent retain cycles

  - Attempting to set a value for a readonly property should raise an exception
  
  - The variable storage is very inefficient (makes mutable copy of collection even when using mutable collection mutation method, so n inserts in O(n^2).), which must be fixed.

  - Check COObject KVO semantics and documentation.
    I think we valueForUndefinedKey
	
  - Throw an exception if the developer names a property that conflicts with a NSObject/COObject method
  
  - Check the set of properties declared by COObject makes sense and isn't too much / too little


  - Remove -copyWithZone: in COObject and CODictionary (but EtoileUI must be migrated to COCopier first)

  - Turn COObject into zombies once garbage collected (see -markAsRemovedFromContext)

  - Keyed CoreObject relationship support (if possible)


- COItem

  - tidy up ugly NSMutableDictionary / NSDictionary casting

  - use a std::unordered_map<NSString *, std::pair<uint32_t, id>>
    (i.e. map from string to (COType, object) pair). 
    
    (Well, use a simple wrapper class instead of std::pair.) We could also
    use SEL instead of NSString* for better performance, probably.


- Collaboration

  - interation btn. sync and branching

  - automatic / continuous sync

  - more test cases

  - use delta compression instead of sending the full snapshot of every revision over the protocol


- COUndoTrack

  - Expose an API for selective undo of actions from the undo/redo stacks

  - Rename COTrack to COHistoryTrack protocol


- Model objects (COObject subclasses included with CoreObject for convenience)

  - for COLibrary, evaluate whether we can enfore the constraint that one persistent root belongs to one library

  - Hide CODictionary as an implementation detail


 - supply commit metadata

 - use cross references

 - use attachments

 - merge UI
 
 - Improve history graph UI. Implement summarization (collapsing minor edits) and
   asynchronously expanding the graph.


- EtoileUI

  - Standardizing on -setValue:forProperty: and -valueForProperty: for COObject/NSObject. Existing methods in ETLayoutItem and ETViewpoint will become -setValue:forRepresentedProperty: and -valueForRepresentedProperty:.


Missing Features
----------------

- Persistent root faulting; currently the entire store is loaded in memory

- Partial loading (loading an object using another entity e.g. COPerson as COObject)

  - Add -persistentEntityDescription (for a partially loaded person object, -persistentEntityDescription would return COPerson when -entityDescription returns COObject)

- Schema Upgrade

- Better query support (in-memory and in-store as sketched in COQuery)

  - NSPredicate to SQL generator using OMeta (not sure)

- Import/Export

- Write a generic object manager than can open any store and display any COObject

  - Should support displaying all key/values (like past StoreBorwser prototypes)
    Not blocking release, but critical for ObjectManager

- Implement something like COSelectiveHistoryTrack (using a query to select revisions based on criterias e.g. inner object subset)

- Something to aggregate the history of multiple persistent roots in this same class?


Open Questions
--------------

- How much support for composite cross-persistent root references should CoreObject provide?
  Would a "deep copy" that recursively makes copies of referenced persistent roots be useful?

- Support transient persistent roots?  These are COObjectGraphContext wrappers.
  Or, support creating a persistent root in code, then calling "freeze" which will make it
  read-only and prevent it from being committed to disk?

- Do cross-store references make sense? i.e. switch from COPath to a URL?

- Adjust COEditingContext loaded object cache to use a strategy that matches which root objects are going to be accessed recurrently (e.g. photos in a Photo Manager should have priority over other root objects)

- Scalability to 50k persistent roots, 50k root objects

- Reintroduce history compaction (will it be needed?), which was present but bitrotted and is not supported right now.
  Possibly just collapse "minor edits" or collapse to daily snapshots + explicit tags. Not sure how much space this will save though.
