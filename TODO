TODO
====

First alpha release blockers
----------------------------

- Fix libdispatch use which prevents CoreObject compilation on GNUstep, we should either extend libobjc2/toydispatch or migrate to the equivalent high-level ObjC API (using NSOperationQueue)

- Fix outdated COCommitDescriptor API doc and review properties (most properties should be read-only probably)

- Check and update all Core API documentation (underway)

- Check code quality for all Core classes (underway)

- Fix GNUstep support

- Write remaing class descriptions

- Implement batch mutation in ETCollection and proper KVO support on top of it in COObject

- The hiding dead cross-references feature is broken and will be very complex to implement correctly:
  See:
  [TestCrossPersistentRootReferences testPersistentRootUndeletion]

  Right now, if you modify a collection after some elements have been
  hidden, the hidden elements will be permanently removed. The correct implementation
  is for every change to a collection with hidden
  elements, diff the collection before and after the change, and apply the diff to 
  the underlying "serialized relationship cache" representation.

  I'm not sure if it's worth supporting hiding dead references at the CoreObject level.

  The alternative is letting UI code check if references are broken and choose how to deal with
  them - could display broken link icon, or hide the reference. This will reduce complexity in
  CoreObject, give UI's more flexibility, but they will have to do some extra
  work to get a good default behaviour (hiding broken refs).

- ProjectDemo should demonstrate more interesting features of CoreObject. 

  - Make FTS search results more usable

  - Some kind of XMPP collaboration demo that shows off per-user undo tracks (underway)

  - Improve the history graph. Should have selective undo and merge buttons

  - Simple diff visualization

- Fix intermittent test failures (TestUndo.m:560, and -[TestSynchronization
  testReplicateToClientWithoutPersistentRoot] exception about "COItem .. lacks an entity name")

- Make attachments a bit more usable - currently can't declare them in the metamodel AFAIK


Future Work
-----------

- GNUstep

  - Add -URLByAppendingPathComponent:isDirectory: and -fileHandleForReadingFromURL:error: to GNUstep (see COSQLiteStore+Attachments)

  - Add -dateWithContentsOfFile:options:error: to GNUstep (see COOCommitDescriptor)

  - Add -predicateWithBlock: to GNUstep (see COQuery)


- Store

  - exportRevisions: and importRevisions: that take a set of CORevisionID an returns a delta-compressed NSData
    suitable for network transport.
	
  - GC: only collect divergent revisions older than X days
  
  - Switch from FMDB to an SQL abstraction backend
  
  - Keep a hash of the revision contents for integrity checking. For this to work
    we need to guarantee that the binary serialization of a COItem is the same
	every time. i.e. sort anything that's unordered in a stable way.


- COEditingContext

  - Expose COSQLiteStore's attachments feature

  - expose COSQLiteStore's finalize deletion method

  - expose store's searching functionality (integrate COSearchResult and COQuery)

  - Switch to NSUUID everywhere?


- COPersistentRoot

  - test [[persistentRoot currentBranch] currentRevision] on a newly created
    persistent root
	
  - Making additional changes to an uncomitted cheap copy persistent root is broken (we
    don't look at the COObjectGraphContext)
	
  - Refactor handling of store notifications

	
- COBranch

  - Extend COBranch API to support branches and merging revisions accross tracks

  - Clean up selective undo code and share implementation with undo system

  - Implement -isCopy and -isTrunkBranch
  

- Metamodel

  - Add checks that derived properties are not persistent

  - Add check that parent property (isContainer = YES) is derived

  - Add check that one side of an opposite is derived

  - Review other constraints

  - Add a check that the derived side of a multivalued opposite is unordered

  - Add an "indexed" flag to ETPropertyDescription to tell the store whether to include values of that property in search indexes

  - Move to CoreObject

  - Scan over every loaded ObjC class is ugly

  - Improve metamodel checker to ensure matching Objective-C property types (e.g. a ETCollection must be declared as multivalued, a NSArray as ordered)
  
  - Add serialization transformer support (this would mean to add -serializationTransformerName and -serializedType { return transformerName != nil ? transformer.type : type } to ETPropertyDescription). This would help to reduce code duplication and potential mistake in serialization accessors, and allow -roundTripValueForProperty: to be usable in tests even if serialization accessors are used. As a result, serialization accessor use would be restricted to just 3 or 5 special cases in EtoileUI.


- COObject

  - Better error message if you try to use a composite relationship across persistent roots, 
    currently you get a COPath does not respond to UUIDValue exception.

  - We should have dedicated array/set multivalue mutation methods rather than using:
    -[COObject (void)insertObject: (id)object atIndex: (NSUInteger)index hint: (id)hint forProperty: (NSString *)key]
    for both, IMO (Eric)

  - Use NSSortedSet for sorted composite relationships

  - Use weak references to other COObject instances to prevent retain cycles

  - Attempting to set a value for a readonly property should raise an exception
  
  - The variable storage is very inefficient (makes mutable copy of collection even when using mutable collection mutation method, so n inserts in O(n^2).), which must be fixed.

  - Check COObject KVO semantics and documentation.
    I think we valueForUndefinedKey
	
  - Throw an exception if the developer names a property that conflicts with a NSObject/COObject method
  
  - Check the set of properties declared by COObject makes sense and isn't too much / too little

  - Remove -copyWithZone: in COObject and CODictionary (but EtoileUI must be migrated to COCopier first)

  - Turn COObject into zombies once garbage collected (see -markAsRemovedFromContext)

  - Keyed CoreObject relationship support (if possible)
  
  - Implement -updateOutgoingSerializedRelationshipCacheForProperty correctly, or else discard the idea
    of automatically hiding broken cross-references.
	
  - Turn _variableStorage into a private ivar once EtoileUI doesn't access it directly
  
  - -valueForVariableStorageKey: or at least the synthesized getter, should return defensive copies if requested in the metamodel (this should even be the default perhaps, especially for collections)


- COItem

  - tidy up ugly NSMutableDictionary / NSDictionary casting

  - use a std::unordered_map<NSString *, std::pair<uint32_t, id>>
    (i.e. map from string to (COType, object) pair). 
    
    (Well, use a simple wrapper class instead of std::pair.) NOTE: using
	SEL as a map key won't work on libobjc2.


- Collaboration

  - use delta compression instead of sending the full snapshot of every revision over the protocol
  
  - support sending attachments (or large persistent roots) using XMPP file transfer


- COUndoTrack

  - Refactor COCommand initialization which is a mess

  - Rename COTrack to COHistoryTrack protocol

  - Reduce commit description related code duplication in CORevision and COCommandGroup

  - Concurrency between processes is not robust (no checking that in-memory
    revisions snapshot is in sync with what is in the DB)

  - e.g:
    a = [COUndoTrack trackForName: @"test" withEditingContext: ctx]
    b = [COUndoTrack trackForName: @"test" withEditingContext: ctx]
	...
	[ctx commitWithUndoTrack: a]

	[a nodes] will not equal [b nodes] but I would expect them to be the equal


- Model objects (COObject subclasses included with CoreObject for convenience)

  - for COLibrary, evaluate whether we can enfore the constraint that one persistent root belongs to one library

  - Hide CODictionary as an implementation detail
  

- ProjectDemo

 - use cross references

 - use attachments

 - merge UI
 
 - Improve history graph UI. Implement summarization (collapsing minor edits) and
   asynchronously expanding the graph.
   
 - merge the remaining useful parts of Typewriter to make a single demo app


- EtoileUI

  - Standardizing on -setValue:forProperty: and -valueForProperty: for COObject/NSObject. Existing methods in ETLayoutItem and ETViewpoint will become -setValue:forRepresentedProperty: and -valueForRepresentedProperty:.


Missing Features
----------------

- Persistent root faulting; currently the entire store is loaded in memory

- Partial loading (loading an object using another entity e.g. COPerson as COObject)

  - Add -persistentEntityDescription (for a partially loaded person object, -persistentEntityDescription would return COPerson when -entityDescription returns COObject)

- Schema Upgrade

- Better query support (in-memory and in-store as sketched in COQuery)

  - NSPredicate to SQL generator using OMeta (not sure)

- Import/Export

- Write a generic object manager than can open any store and display any COObject

  - Should support displaying all key/values (like past StoreBorwser prototypes)
    Not blocking release, but critical for ObjectManager

- Implement something like COSelectiveHistoryTrack (using a query to select revisions based on criterias e.g. inner object subset)

- Something to aggregate the history of multiple persistent roots in this same class?


Open Questions
--------------

- Currently COUndoTrack is conservative and won't let you make an undo that would result
  in merge conflicts. However, we could easily relax this constraint and automatically resolve
  conflicts favouring the newer commit (for example). Auto-resolving seems
  to work well in practice (I'm doing it in COSynchronizer).

- How much support for composite cross-persistent root references should CoreObject provide?
  Would a "deep copy" that recursively makes copies of referenced persistent roots be useful?

- Support transient persistent roots?  These are COObjectGraphContext wrappers.
  Or, support creating a persistent root in code, then calling "freeze" which will make it
  read-only and prevent it from being committed to disk?

- Do cross-store references make sense? i.e. switch from COPath to a URL?

- Adjust COEditingContext loaded object cache to use a strategy that matches which root objects are going to be accessed recurrently (e.g. photos in a Photo Manager should have priority over other root objects)

- Scalability to 50k persistent roots, 50k root objects

- Reintroduce history compaction (will it be needed?), which was present but bitrotted and is not supported right now.
  Possibly just collapse "minor edits" or collapse to daily snapshots + explicit tags. Not sure how much space this will save though.
