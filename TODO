TODO
====

First alpha release blockers
----------------------------

- Remove -commitWithType:shortDescription:

  - Used in ProjectDemo

- Add some collection-oriented KVO update tests to TestObjectUpdate

- Fix test suite compilation on GNUstep

  - Add -[NSNotificationCenter addObserverForName:object:queue:usingBlock:] to GNUstep

  - For compatibility with the current GNUstep release, perhaps emulate -addObserverForName:object:queue:usingBlocks: in a category or TestCommon

- Fix GNUstep support

  - Samples

  - All tests pass for both CoreObject and EtoileUI test suite

- Check and update all Core API documentation (underway)

- Check code quality for all Core classes (underway)

	- Already reviewed classes: COObjectGraphContext

- Write remaing class descriptions

- Implement support for "dead cross-references"; currently an assertion will fail.
  Or, postpone this until after first release? 

- ProjectDemo should demonstrate more interesting features of CoreObject. 

  - Make FTS search results more usable

  - Some kind of XMPP collaboration demo that shows off per-user undo tracks (underway)

  - Improve the history graph. Should have selective undo and merge buttons

  - Simple diff visualization


Future Work
-----------

- GNUstep

  - Add -URLByAppendingPathComponent:isDirectory: and -fileHandleForReadingFromURL:error: to GNUstep (see COSQLiteStore+Attachments)

  - Add -dateWithContentsOfFile:options:error: to GNUstep (see COOCommitDescriptor)

  - Add -predicateWithBlock: to GNUstep (see COQuery)


- Store

  - exportRevisions: and importRevisions: that take a set of CORevisionID an returns a delta-compressed NSData
    suitable for network transport.
	
  - GC: only collect divergent revisions older than X days
  
  - Switch from FMDB to an SQL abstraction backend
  
  - Keep a hash of the revision contents for integrity checking. For this to work
    we need to guarantee that the binary serialization of a COItem is the same
	every time. i.e. sort anything that's unordered in a stable way.


- COEditingContext

  - Expose COSQLiteStore's attachments feature

  - expose COSQLiteStore's finalize deletion method

  - expose store's searching functionality (integrate COSearchResult and COQuery)

  - Switch to NSUUID everywhere?

  - Expose COEditingContext(Debugging), probably with a header we can explicit import (should be outside of COEditingContext+Private)
  
  - Test editing context with no store
  
  	- Not sure the behavior is still well defined. Could be better to move to a COInMemoryStore (just a null pattern implementation).


- COPersistentRoot

  - test [[persistentRoot currentBranch] currentRevision] on a newly created
    persistent root
	
  - Making additional changes to an uncomitted cheap copy persistent root is broken (we
    don't look at the COObjectGraphContext)
	
  - Refactor handling of store notifications
  
  - Add -initialRevision?

	
- COBranch

  - Extend COBranch API to support branches and merging revisions accross tracks

  - Clean up selective undo code and share implementation with undo system

  - Implement -isCopy and -isTrunkBranch
  

- COPersistentObjectContext

	- Find a better name for this protocol, that gives it less importance, and convey it can represent a transient object graph context (or at least doesn't go against this use case). 
	
	- Perhaps move it to EtoileUI


- Metamodel

  - Add checks that derived are not persistent (readonly can be persistent, for set-once properties. Useful for immutable objects).

  - Add check that parent property (isContainer = YES) is derived

  - Add check that one side of an opposite is derived

  - Review other constraints

  - Add a check that the derived side of a multivalued opposite is unordered
  
  - Add a check that complains about ivars for incoming relationships
  
  - Add constraint stating that a keyed relationships cannot have an opposite (at least for now)

  - Add an "indexed" flag to ETPropertyDescription to tell the store whether to include values of that property in search indexes

  - Move to CoreObject

  - Scan over every loaded ObjC class is ugly

  - Improve metamodel checker to ensure matching Objective-C property types (e.g. a ETCollection must be declared as multivalued, a NSArray as ordered)
  
  - Add serialization transformer support (this would mean to add -serializationTransformerName and -serializedType { return transformerName != nil ? transformer.type : type } to ETPropertyDescription). This would help to reduce code duplication and potential mistake in serialization accessors, and allow -roundTripValueForProperty: to be usable in tests even if serialization accessors are used. As a result, serialization accessor use would be restricted to just 3 or 5 special cases in EtoileUI.
  
  	  - Add a check that complains about serialization accessors or serialization transformers for relationships if there is no custom persistent type declared


- COObject

  - Better error message if you try to use a composite relationship across persistent roots, 
    currently you get a COPath does not respond to UUIDValue exception.

  - We should have dedicated array/set multivalue mutation methods rather than using:
    -[COObject (void)insertObject: (id)object atIndex: (NSUInteger)index hint: (id)hint forProperty: (NSString *)key]
    for both, IMO (Eric)

  - Use NSOrderedSet for relationships
    
  - Throw an exception if the developer names a property that conflicts with a NSObject/COObject method

  - Remove -copyWithZone: in COObject and CODictionary (but EtoileUI must be migrated to COCopier first)

  - Turn COObject into zombies once garbage collected (see -markAsRemovedFromContext)
	
  - Turn _variableStorage into a private ivar once EtoileUI doesn't access it directly
  
  - Add dictionary update tests to TestObjectUpdate.m
  
  - Add relationship update check to detect persistent objects inserted into a transient relationship. The object put in the relationship could belong to:
  
    - a transient object graph context --> allowed (see transient property _dropIndicator in -[ETLayout awakeFromDeserialization)
    - the same object graph context --> disallowed (otherwise we can accidentally easily look up shared instance using the wrong object graph context e.g. _dropIndicator = [ETDropIndicator sharedInstanceForObjectGraphContext: [layout objectGraphContext]])
    - some other persistent object graph context --> allowed or disallowed (not sure yet)

  - Make primitives with potentially mutable subclasses (NSString and NSData)
    have immutable copies made before being stored in the variable storage.

  - Add more transient relationship tests


- COItem

  - tidy up ugly NSMutableDictionary / NSDictionary casting

  - use a std::unordered_map<NSString *, std::pair<uint32_t, id>>
    (i.e. map from string to (COType, object) pair). 
    
    (Well, use a simple wrapper class instead of std::pair.) NOTE: using
	SEL as a map key won't work on libobjc2.


- Collaboration

  - support sending attachments (or large persistent roots) using XMPP file transfer


- COUndoTrack

  - Refactor COCommand initialization which is a mess

  - Rename COTrack to COHistoryTrack protocol

  - Reduce commit description related code duplication in CORevision and COCommandGroup

  - Concurrency between processes is not robust (no checking that in-memory
    revisions snapshot is in sync with what is in the DB)

  - e.g:
    a = [COUndoTrack trackForName: @"test" withEditingContext: ctx]
    b = [COUndoTrack trackForName: @"test" withEditingContext: ctx]
	...
	[ctx commitWithUndoTrack: a]

	[a nodes] will not equal [b nodes] but I would expect them to be the equal


- Model objects (COObject subclasses included with CoreObject for convenience)

  - for COLibrary, evaluate whether we can enfore the constraint that one persistent root belongs to one library
  
  - Test unordered COCollection subclass
  

- Serialization

  - Make a strict set of supported types, see: Scraps/serialization_todo.txt

  - For collection metamodel assertions, check all collection metamodel attributes (isKeyed, isOrdered, isMultivalued) and document we should update these assertions if we add more collection attributes to the metamodel:
  
		NSAssert([aPropertyDesc isKeyed] && [aPropertyDesc isMultivalued], @"Serialization type doesn't match metamodel");


- Utilities

  - Define some CoreObject exceptions perhaps
	
    - COAbstractClassInitializationException
    - COImmutableCollectionMutationException
    - what else?
 
  - Write commit descriptor tests (localization is untested at this time)
	
  - Implement copying commit descriptor plist and string files to ~/Library/CoreObject/Commits, in order to support browsing changes done by applications uninstalled from the system
	
  - Integrate COCommitDescriptor with Schema Upgrade 
	
    - adjust to support versioned descriptors 
    - multiple commit descriptor versions can present per domain in ~/Library/CoreObject/Commits
	

- ProjectDemo

 - use cross references

 - use attachments

 - merge UI
 
 - Improve history graph UI. Implement summarization (collapsing minor edits) and
   asynchronously expanding the graph.
   
 - merge the remaining useful parts of Typewriter to make a single demo app


- EtoileUI

  - Standardizing on -setValue:forProperty: and -valueForProperty: for COObject/NSObject. Existing methods in ETLayoutItem and ETViewpoint will become -setValue:forRepresentedProperty: and -valueForRepresentedProperty:.


Missing Features
----------------

- Persistent root faulting; currently the entire store is loaded in memory

- Partial loading (loading an object using another entity e.g. COPerson as COObject)

  - Add -persistentEntityDescription (for a partially loaded person object, -persistentEntityDescription would return COPerson when -entityDescription returns COObject)

- Schema Upgrade

- Better query support (in-memory and in-store as sketched in COQuery)

  - NSPredicate to SQL generator using OMeta (not sure)

- Import/Export

- Write a generic object manager than can open any store and display any COObject

  - Should support displaying all key/values (like past StoreBorwser prototypes)
    Not blocking release, but critical for ObjectManager

- Implement something like COSelectiveHistoryTrack (using a query to select revisions based on criterias e.g. inner object subset)

- Something to aggregate the history of multiple persistent roots in this same class?


Open Questions
--------------

- Support transient persistent roots?  These are COObjectGraphContext wrappers.
  Or, support creating a persistent root in code, then calling "freeze" which will make it
  read-only and prevent it from being committed to disk?

- Do cross-store references make sense? i.e. switch from COPath to a URL?

- Adjust COEditingContext loaded object cache to use a strategy that matches which root objects are going to be accessed recurrently (e.g. photos in a Photo Manager should have priority over other root objects)

- Scalability to 50k persistent roots, 50k root objects

- Reintroduce history compaction (will it be needed?), which was present but bitrotted and is not supported right now.
  Possibly just collapse "minor edits" or collapse to daily snapshots + explicit tags. Not sure how much space this will save though.
