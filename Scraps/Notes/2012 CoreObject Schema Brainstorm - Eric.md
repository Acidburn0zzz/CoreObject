CoreObject Schema Brainstorm
============================

	/** A svn-style branch, or maybe a Lightroom-style varaition?
	 */
	{ type<string> = branch;
	  branch-uuid = 'abcdef'; // identity
	
	  label<string> = 'My variation #1';
	  version = 'abcedf'; // reference to a version object
	}
	
	/**
	 * - Boundary for copying references in copy/paste/drag&drop. (closest-parent-version)
	 * - as a side effect we get this property:
	 * ( making something branchable that was just a  sub-part of a document
	 *   , like an embedded graphic, we also want to add a copy-boundary around
	 *   it to avoid the 'paradoxes' we discovered earlier from occurring. so it's OK that
	 *   to tie together 'being a copy-boundary' with 'being a branch holder' as one object
	 *   and call it a 'document')
	 * - as a side effect, we get properties like: Drag and drop an object in to an old version
	 *   of a document creates an implicit branch, and forces a copy to be made.
	 */
	{ type<string> = version
	  version-uuid = 'abcdef'; // identity
	
	  parent-version-uuids = [ 'abcdef' ]; // the history DAG
	
	  data<object> = ? strong. // the actual snapshot of the versioned sub-tree
	}
	
	/**
	 * (nestable) unit of versioning. Supports branching. Has a notion of a current set of interesting
	 * branches.
	 */
	{ type<string> = document;
	  label<string> = 'My document';
	  date-modified = 'dd/mm/yyyy';
	  branches<branch> = [] strong;
	  current-branch-uuid = 'abcdef' // this is for looking up the correct branch object in the branches array
	
	  versions = [] strong; // all the versions are simply stored in an array. (order is arbitrary)
	                        // the versions themselves store the DAG as weak references.
	}


The above seems to come closest to being able to create a sane version-controlled composite document/project. the main thing I'm unsure about are:

 - immutable objects identified use hashing like git? or not?
 - selective undo, or normal undo?
 - global UUID namespace, or paths?
     - do we need to be able to represent, in our store, a reference to a particular version of an object? YES
       how are uuid references to be interpreted?

ok.. how do we work in undo/redo when there's a view and we want selection changes to be undoable?
    idea: 
  
  - each view on the model is a separate object.
  - the views only have weak refs to the model (why? copying a view shouldn't copy the underlying model object)
  - selection changes could be recorded simply by having a 'current-selection' property
  - then the undo/redo UI is generated by unioning the undo/redo streams from the view and the model.
    this should allow undo/redo of selection and model edits on, say, two views of a large vector graphics doc
    work OK, with no need for selective undo.


question: can we get rid of the intermediate history graphs?

---

we need Versioned Core Objects and embedded objects to have the same structure, so you can “discard version data” of a Versioned Core Object to turn it in to an embedded object, and “make versioned” an embedded object.

problem is, if we go with the JCR-like ‘every object has a “contents” property containing the contained objects’ idea, then
we run in to the old problem of ordered vs unordered contents, and how this affects diff/merge.

options:

1. deal with jcr model (sub-objects can only be in the blessed ‘contents’ property)
2. deal with jcr, but add the ability to mark the contents property as ordered/unordered
3. OM1 like metamodel where any property can contain sub- embedded objects/versioned core objects. arrays can be ordered/unordered.

NOTE: there is no notion of strong/weak, only sub- embedded objects/versioned core objects and UUID’s or however we do weak refs.