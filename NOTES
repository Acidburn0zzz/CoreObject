Problem: Conflict handling....
------------------------------

-> in some cases we'll want a most-recent-wins policy (however conflict metadata
   should still be saved in the db.)
  
Open question: when a merge generates conflicts, should the user be able to
resolve them at a finer granularity than a commit? probably not..

Solution: 
not sure.


Problem: non-temporal changes
-----------------------------
changes could be divided in to 3 categories:
- non-persistent
- persistent, non-temporal 
    (e.g. setting the "last printed date" property of a document - shouldn't be undoable)
    All versions of an object share the same value for these properties - 
    they are unaffected by revert operations.
    Handling this could potentially be a big pain. For example, commiting a
    change to a non-temporal property can fail (if it was modified since the
    start of the transaction), unlike a change to a temporal property which
    never fails since it implicitly creates a branch.
    
- persistent, temporal (normal properties of objects; changes can be undone)

Solution:
non-persistent : not handled by CoreObject
persistent, non-temporal : handled by setting an attribute on a HistGraphNode to
                           have it be skipped in the undo/redo UI, but otherwise
                           treat it like a temporal property.
                           This wastes space, but is probably the cleanest
                           way of handling these.
persistent, temporal : default behaviour.


Problem: Weak/strong properties
-------------------------------

objects referred to by a strong attribute are treated as "part of" the obejct.
so when performing operations on a particular object, e.g. "revert to revision",
all strongly referenced objects are also reverted.
weak references are usually for 'parent' relationships (e.g. when you revert 
an object, you don't want to revert the container it is in)

Solution: strong is the default. Can set a 'weak' modifier on an attribute.

Problem:
------
viewing history graph of an object
solution:
1. generate set of all strongly referenced COObjects + the base object
  [ this could be a lot of objects. ]
2. for each node in the overall history graph, if (modified objects
 intersects set from 1.), include node in the graph



Diff notes
----------

Currently, for diffing ordered sequences, I'm using a BSD-licensed C++ implementation
(diff.hh) of the Myers algorithm, the same algorithm GNU diff implements.
It doesn't really need to be C++, that was just easiest for me to work with
when porting it from C#.

The GNU algorithm has some heuristics which my implementation lacks, so the GNU
code is faster in some cases. I think this mostly affects diffing unrelated arrays.
I did one test case with 130k element arrays, and large unrelated sections.
GNU diff was about 0.3s, and mine was 3.0s. Not too much worse, anyway.

Another algorithm I investigated is the one used in python's difflib. It's
conceptually very simple (find the longest common _substring_, then recursively
repeat the algorithim on the two non-common sides of the string. This
will incrementally generate a long common subsequence (i.e. diff). I wrote a 
test implementation in ObjC but it was too slow -- need to play with the idea 
a bit more.


Other links:
- libxdiff (http://www.xmailserver.org/xdiff-lib.html), LGPL
   This has a collection of algorithims including the python one and the myers one
   with the heuristics, but is LGPL licensed.

- libmba (http://www.ioplex.com/~miallen/libmba/dl/src/diff.c), MIT
   Myers algorithm
   
- google-diff-patch-match (http://code.google.com/p/google-diff-match-patch), ApacheV2

- patience diff (http://bramcohen.livejournal.com/73318.html)
   This seems to produce output similar to the python algorithim.
   